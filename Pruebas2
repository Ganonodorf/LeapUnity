using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;
using RotateBomba;

public class ControlTetris2 : MonoBehaviour {

    // Estableciendo variables
    GameObject pieza;
    GameObject sombra;

    // Se hace una matriz para el escenario y otra para guardar la posición de la pieza en todo momento
    public int[,] escenario = new int[21, 10];
    public int[,] piezaAct;
    const float TimeFijo = 0.2f;
    float time = 0.0f;

    public bool fijar = false;

    // Use this for initialization
    void Start ()
    {
        // Pieza inicial
        pieza = NewPieza();

        // Rellenando la matriz de 0s
        for (int i = 0; i < 21; i++)
        {
            for (int j = 0; j < 10; j++)
            {
                escenario[i, j] = 0;
            }
        }
    }

    // Update is called once per frame
    void Update() {
        // Sumamos tiempo al contador
        time += Time.deltaTime;

        // Inicializamos las variables para luego acceder al script
        GameObject control = GameObject.Find("Control");
        LeapTest leaptest = control.GetComponent<LeapTest>();

        // Se mira donde está la mano y se mueve la pieza
        MoverHoriz();

        // Si se ha llegado a 1 segundo, la pieza baja
        if (time >= TimeFijo)
        {
            // Primero se mueve abajo, y si no se puede, fijar sera true, por lo que la pieza se colocara
            Mover("Abajo");
            if (fijar == true)
            {
                ColocarPieza();
                fijar = false;
            }
            time = 0;
        }

        // Si se mueve el dedo, la pieza cae
        //if (leaptest.caer == true)
        //{
        //    // Se baja la pieza
        //    ColocarPieza();
        //    leaptest.caer = false;
        //}
        
    }

    public GameObject NewPieza()
    {
        // Se escoge pieza aleatoriamente y se guarda en la matriz del escenario
        int num = Random.Range(0, 7);
        string sPieza;
        switch (num)
        {
            case 0:
                sPieza = "O";
                escenario[19, 4] = 2; escenario[19, 5] = 2; escenario[20, 4] = 2; escenario[20, 5] = 2;
                piezaAct = new int[,] { { 19, 4 }, { 19, 5 }, { 20, 4 }, { 20, 5 } };
                break;
            case 1:
                sPieza = "I";
                escenario[19, 4] = 2; escenario[19, 3] = 2; escenario[19, 5] = 2; escenario[19, 6] = 2;
                piezaAct = new int[,] { { 19, 4 }, { 19, 3 }, { 19, 5 }, { 19, 6 } };
                break;
            case 2:
                sPieza = "Z";
                escenario[19, 4] = 2; escenario[19, 5] = 2; escenario[20, 4] = 2; escenario[20, 3] = 2;
                piezaAct = new int[,] { { 19, 4 }, { 19, 5 }, { 20, 4 }, { 20, 3 } };
                break;
            case 3:
                sPieza = "Zinv";
                escenario[19, 4] = 2; escenario[19, 3] = 2; escenario[20, 4] = 2; escenario[20, 5] = 2;
                piezaAct = new int[,] { { 19, 4 }, { 19, 3 }, { 20, 4 }, { 20, 5 } };
                break;
            case 4:
                sPieza = "L";
                escenario[19, 4] = 2; escenario[19, 5] = 2; escenario[19, 3] = 2; escenario[18, 3] = 2;
                piezaAct = new int[,] { { 19, 4 }, { 19, 5 }, { 20, 3 }, { 18, 3 } };
                break;
            case 5:
                sPieza = "Linv";
                escenario[19, 4] = 2; escenario[19, 5] = 2; escenario[19, 3] = 2; escenario[18, 5] = 2;
                piezaAct = new int[,] { { 19, 4 }, { 19, 5 }, { 19, 3 }, { 18, 5 } };
                break;
            case 6:
                sPieza = "T";
                escenario[19, 4] = 2; escenario[19, 5] = 2; escenario[19, 3] = 2; escenario[18, 4] = 2;
                piezaAct = new int[,] { { 19, 4 }, { 19, 5 }, { 19, 3 }, { 18, 4 } };
                break;
            //Por si se vuelve loco, que devuelva algo
            default:
                sPieza = "O";
                escenario[19, 4] = 2; escenario[19, 5] = 2; escenario[20, 4] = 2; escenario[20, 5] = 2;
                piezaAct = new int[,] { { 19, 4 }, { 19, 5 }, { 20, 4 }, { 20, 5 } };
                break;
        }

        // Creacion de la sombra.
        Object prefab = AssetDatabase.LoadAssetAtPath("Assets/Piezas/" + sPieza + ".prefab", typeof(GameObject));
        //sombra = Instantiate(prefab, new Vector3(4.0f, 17.0f, 0.0f), Quaternion.identity) as GameObject;

        // Creacion de pieza
        pieza = Instantiate(prefab, new Vector3(4.0f, 19.0f, 0.0f), Quaternion.identity) as GameObject;
        return pieza;
    }

    public void MoverHoriz()
    {
        // Accedemos a LeapTest
        GameObject control = GameObject.Find("Control");
        LeapTest leaptest = control.GetComponent<LeapTest>();

        float Xmano = (float)leaptest.XAngle;
        float Ymano = (float)leaptest.YAngle;

        // Posicion actual de la pieza, la sombra también se desplaza
        float Yactual = pieza.transform.position.y;
        //float Ysombra = sombra.transform.position.y;

        if (Ymano < -90) {                              pieza.transform.position = new Vector3(9.0f, Yactual, 0.0f); //sombra.transform.position = new Vector3(9.0f, Ysombra, 0.0f);                                             
        } else if ((-90 <= Ymano) && (Ymano < -60)) {   pieza.transform.position = new Vector3(8.0f, Yactual, 0.0f); //sombra.transform.position = new Vector3(8.0f, Ysombra, 0.0f);
        } else if ((-60 <= Ymano) && (Ymano < -30)) {   pieza.transform.position = new Vector3(7.0f, Yactual, 0.0f); //sombra.transform.position = new Vector3(7.0f, Ysombra, 0.0f);
        } else if ((-30 <= Ymano) && (Ymano < 0)) {     pieza.transform.position = new Vector3(6.0f, Yactual, 0.0f); //sombra.transform.position = new Vector3(6.0f, Ysombra, 0.0f);
        } else if ((0   <= Ymano) && (Ymano < 30)) {    pieza.transform.position = new Vector3(5.0f, Yactual, 0.0f); //sombra.transform.position = new Vector3(5.0f, Ysombra, 0.0f);
        } else if ((30  <= Ymano) && (Ymano < 60)) {    pieza.transform.position = new Vector3(4.0f, Yactual, 0.0f); //sombra.transform.position = new Vector3(4.0f, Ysombra, 0.0f);
        } else if ((60  <= Ymano) && (Ymano < 90)) {    pieza.transform.position = new Vector3(3.0f, Yactual, 0.0f); //sombra.transform.position = new Vector3(3.0f, Ysombra, 0.0f);
        } else if ((90  <= Ymano) && (Ymano < 120)) {   pieza.transform.position = new Vector3(2.0f, Yactual, 0.0f); //sombra.transform.position = new Vector3(2.0f, Ysombra, 0.0f);
        } else if ((120 <= Ymano) && (Ymano < 150)) {   pieza.transform.position = new Vector3(1.0f, Yactual, 0.0f); //sombra.transform.position = new Vector3(1.0f, Ysombra, 0.0f);
        } else {                                        pieza.transform.position = new Vector3(0.0f, Yactual, 0.0f); //sombra.transform.position = new Vector3(0.0f, Ysombra, 0.0f);
        }
    }

    public bool Mover(string mov)
    {
        bool sepuede = false;
        if (EsPosible(mov))
        {
            Movimiento(mov);
            sepuede = true;
        }
        return sepuede;
    }

    public bool EsPosible(string mov)
    {
        bool sepuede = true;
        int contador = 0;
        switch (mov)
        {
            case "Abajo":
                while((contador < 4) && (sepuede == true))
                {
                    if (piezaAct[contador, 0] == 0)                     // Primero se ve si la pieza está en el suelo
                    {
                        sepuede = false;
                        fijar = true;
                    }
                    else if (escenario[piezaAct[0, 0] - 1, piezaAct[0, 1]] == 1) // Despues si hay otra pieza abajo, no se hace en el mismo if para no acceder
                    {                                                            // por error a escenario de -1
                        sepuede = false;
                        fijar = true;
                    }
                    else                                                         // Si todo va bien, abajo está la propia pieza o nada, pasamos a la siguiente
                    {
                        contador++;
                    }
                }
                break;
        }
        return sepuede;
    }

    public void Movimiento(string mov)
    {
        int[,] piezaNueva = piezaAct;
        switch (mov)
        {
            case "Abajo":
                // Primero se pinta el escenario de 0
                for(int i = 0; i < 4; i++)
                {
                    escenario[piezaAct[i, 0], piezaAct[i, 1]] = 0;
                }

                // Luego se baja la pieza actual una posición y se pinta la nueva posición en el escenario
                for (int i = 0; i < 4; i++)
                {
                    piezaAct[i, 0] -= 1;
                    escenario[piezaAct[i, 0], piezaAct[i, 1]] = 2;
                }

                // Se baja la pieza en unity
                pieza.transform.position = new Vector3(pieza.transform.position.x, pieza.transform.position.y - 1, 0.0f);
                break;
        }
    }
    public void ColocarPieza()
    {
        // Donde este la pieza se pintan 1s y se crea una nueva pieza, con piezaAct nuevo
        for (int i = 0; i < 4; i++)
        {
            escenario[piezaAct[i, 0], piezaAct[i, 1]] = 1;
        }
        pieza = NewPieza();
    }
}
